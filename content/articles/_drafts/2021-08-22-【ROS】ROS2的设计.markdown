---
layout: post
title: 【ROS】ROS2的设计
categories: ROS
---

## ROS的诞生
ROS的生命起始于Willow Garage PR2机器人的诞生。

## ROS的理念？
## ROS的模型

## ROS2的开发
ROS2于2014年的ROSCon上首次被提出，正式开发始于2015年，标记了ROS发展新纪元的开始。关于ROS2的设计理念，这里有一个很好的网站 [ROS 2 Design](https://design.ros2.org).

## ROS1和ROS2的变化
### 平台和依赖性
- ROS1目前只在Ubuntu上进行CI测试。ROS2则有可能对应Ubuntu（Linux），MacOS，Windows等多种平台。
- ROS1的核心是针对C++03的。ROS2广泛使用C+11，并使用C++14的一些部分。在未来，ROS2可能会开始使用C++17。
- ROS1针对Python2，ROS2至少需要Python3.5版本。

### 现有中间件的再利用
ROS1使用了一个自定义的序列化格式，一个自定义的传输协议以及一个自定义的中央发现机制。ROS2有一个抽象的中间剪接口，通过它提供序列化，传输和发现。目前ROS2这个接口的所有实现都是基于DDS标准（DDS标准链接）的。这使得ROS2能够提供各种服务质量策略，改善不同网络的通信。
https://ja.wikipedia.org/wiki/Data_Distribution_Service


### 构建系统
catkin与ament
支持CMake以外的其他构建系统

### Python软件包
In ROS 1 a package with Python code can only use a small subset of the features available in setup.py files since the setup.py file is being processed by custom logic from within CMake. In ROS 2 a Python package can use anything in setup.py files, e.g. entry points since they are being invoked with python3 setup.py install.
在ROS 1中，带有Python代码的软件包只能使用setup.py文件中的一小部分功能，因为setup.py文件是由CMake中的自定义逻辑处理的。在ROS 2中，Python包可以使用setup.py文件中的任何东西，例如入口点，因为它们被python3 setup.py install调用了。

### 环境设置
在ROS1中，构建工具会生成一些脚本。在使用构建的ROS包之前，必须先设置环境。这种方法只在使用ROS特定的构建工具构建ROS包时有效。
ROS2中，环境设置被分离成特定于包的脚本和特定于工作区的脚本。每个包都提供了必要的脚本，以便自己在被构建后可以使用。构建工具只调用工作区特定的脚本，然后再调用包的脚本。

#### No 非隔离式的构建
在ROS1中，多个软件包可以在一个CMake上下文中构建。虽然这加快了构建步骤，但每个软件包都需要确保跨软件包的目标依赖被正确定义。此外，所有的包都共享相同的命名空间，这导致了目标名称的冲突等。
在ROS2中，只支持隔离式构建，即每个软件包都是单独构建的。安装空间可以是隔离的，也可以是合并的。

#### 无开发空间（No devel space）
在ROS1中，软件包可以在不安装的情况下被构建。从发展空间与源空间的结合来看，系统已经可以使用的。但是每个软件包都必须支持开发空间（例如，在环境钩子和CMake代码中）
在ROS2中，一个软件包必须在构建后安装才能使用。
在ROS1中，开大空间的一个原因是使开发者能够改变文件，例如Python代码或启动文件，并直接使用修改后的代码，而不需要重建软件包。在ROS2中，这一好处被保留了下来，在安装步骤中可以选择用符号链接代替复制操作。

### 对没有清单的软件包的最低限度支持
ROS1中，构建系统只考虑有清单文件（manifest file）的文件包。ROS2中可以在没有清单的文件的文件夹中检测到支持构建系统的软件包。如果软件包遵循common practice，还有可能检测到一些缺失的元信息。

http://design.ros2.org/articles/build_tool.html